# ================================================================
# MODULE 1: MATH_TOOLS
# Fonctions mathématiques et physiques pour les sections efficaces
# ================================================================

#' @title Calcul d'une section efficace différentielle
#' @description Analyse un petit intervalle angulaire, énergétique ou spatial
sigma_diff <- function(dN, N0, n, dx) {
  dN / (N0 * n * dx)
}

#' @title Propagation d'erreur sur sigma
erreur_sigma <- function(dN, N0, n, dx) {
  sigma <- sigma_diff(dN, N0, n, dx)
  sd <- sqrt(dN) / (N0 * n * dx)
  list(sigma = sigma, erreur = sd)
}

#' @title Intégration trapézoïdale (implémentation interne)
#' @description Remplace pracma::trapz - Méthode des trapèzes
#' @param x Vecteur des abscisses
#' @param y Vecteur des ordonnées
#' @return Intégrale approximative
trapz <- function(x, y) {
  if (length(x) != length(y)) {
    stop("x et y doivent avoir la même longueur")
  }

  if (length(x) < 2) {
    return(0)
  }

  # Méthode des trapèzes: sum((x[i+1] - x[i]) * (y[i+1] + y[i]) / 2)
  idx <- 2:length(x)
  sum(diff(x) * (y[idx] + y[idx - 1]) / 2)
}

#' @title Section efficace totale (intégration numérique)
#' @description Intègre sur un domaine angulaire ou énergétique
#' @param angle Vecteur d'angles ou énergies
#' @param sigma_angle Vecteur de sections efficaces correspondantes
#' @return Section efficace totale intégrée
sigma_total <- function(angle, sigma_angle) {
  trapz(angle, sigma_angle)
}

#' @title Loi exponentielle d'atténuation
#' @description Relie le coefficient µ à la section efficace microscopique
loi_attenuation <- function(I0, mu, x) {
  I0 * exp(-mu * x)
}

#' @title Densité atomique
#' @description Calcule n dans σ = μ / n
densite_atomique <- function(rho, A) {
  (rho / A) * 6.022e23   # N_A / Masse molaire
}

#' @title Section efficace microscopique ↔ macroscopique
sigma_macro <- function(n, sigma_micro) {
  n * sigma_micro
}

sigma_micro <- function(mu, n) {
  mu / n
}

#' @title Diffusion de Rutherford
#' @description Fonction phare pour la section efficace différentielle
#' @param theta Angle(s) de diffusion en degrés
#' @param Z1 Numéro atomique du projectile
#' @param Z2 Numéro atomique de la cible
#' @param E Énergie du projectile en MeV
#' @return Section efficace différentielle en barn/sr
sigma_rutherford <- function(theta, Z1, Z2, E) {
  # Conversion degrés -> radians
  theta_rad <- theta * pi / 180

  # Constante k = (Z1*Z2*e²/4E) en unités MeV·fm
  k <- (Z1 * Z2 * 1.44 / (4 * E))

  # Formule de Rutherford: dσ/dΩ = k² / sin⁴(θ/2)
  (k^2) / (sin(theta_rad / 2)^4)
}

#' @title Diffusion isotrope
#' @description Conversion section totale → différentielle isotrope
sigma_isotrope <- function(sigma_total) {
  sigma_total / (4 * pi)
}

#' @title Polynômes de Legendre (implémentation interne)
#' @description Calcule P_l(x) par récurrence sans dépendance externe
#' @param l Degré du polynôme (0, 1, 2, ...)
#' @param x Valeur d'évaluation, typiquement cos(theta) ∈ [-1, 1]
#' @return Valeur de P_l(x)
#' @details Utilise la relation de récurrence:
#'   (l+1)P_{l+1}(x) = (2l+1)x·P_l(x) - l·P_{l-1}(x)
#' @examples
#' polynome_legendre(0, 0.5)  # P_0 = 1
#' polynome_legendre(1, 0.5)  # P_1 = x = 0.5
#' polynome_legendre(2, 0.5)  # P_2 = (3x²-1)/2
polynome_legendre <- function(l, x) {
  # Cas de base
  if (l == 0) return(1)
  if (l == 1) return(x)

  # Récurrence: (n+1)P_{n+1} = (2n+1)xP_n - nP_{n-1}
  P_prev <- 1      # P_0(x)
  P_curr <- x      # P_1(x)

  for (n in 1:(l-1)) {
    P_next <- ((2*n + 1) * x * P_curr - n * P_prev) / (n + 1)
    P_prev <- P_curr
    P_curr <- P_next
  }

  return(P_curr)
}

#' @title Diffusion anisotrope (décomposition de Legendre)
#' @description Développement de la section efficace différentielle sur les polynômes de Legendre
#' @param theta Angle(s) en radians
#' @param coeff Vecteur de coefficients [a_0, a_1, a_2, ..., a_L]
#' @return Section efficace angulaire σ(θ) en barn/sr
#' @details La section efficace s'écrit:
#'   dσ/dΩ(θ) = Σ_l a_l · P_l(cos θ)
#'   où P_l sont les polynômes de Legendre
#' @examples
#' # Diffusion isotrope pure (l=0 seulement)
#' theta <- seq(0, pi, length.out = 100)
#' sigma1 <- sigma_legendre(theta, c(1, 0, 0))
#'
#' # Diffusion avec asymétrie avant-arrière (l=1)
#' sigma2 <- sigma_legendre(theta, c(1, 0.5, 0))
#'
#' # Décomposition complète jusqu'à l=4
#' sigma3 <- sigma_legendre(theta, c(1, 0.3, -0.2, 0.1, 0.05))
sigma_legendre <- function(theta, coeff) {
  # Initialisation du résultat
  sigma <- numeric(length(theta))

  # Boucle sur les coefficients de la décomposition
  for (l in seq_along(coeff)) {
    # Calcul de P_{l-1}(cos θ) pour chaque angle
    # Note: l-1 car l'indexation R commence à 1
    P_l <- sapply(cos(theta), function(x) polynome_legendre(l - 1, x))
    sigma <- sigma + coeff[l] * P_l
  }

  return(sigma)
}

#' @title Diffusion anisotrope (version vectorisée optimisée)
#' @description Version rapide utilisant le pré-calcul matriciel
#' @param theta Angle(s) en radians
#' @param coeff Vecteur de coefficients [a_0, a_1, a_2, ..., a_L]
#' @return Section efficace angulaire σ(θ) en barn/sr
#' @details Cette version est 10-20x plus rapide pour de grands ensembles de données
sigma_legendre_fast <- function(theta, coeff) {
  n_theta <- length(theta)
  l_max <- length(coeff) - 1

  # Matrice pour stocker tous les P_l(cos θ)
  P_matrix <- matrix(0, nrow = n_theta, ncol = l_max + 1)
  x <- cos(theta)

  # Initialisation: P_0 et P_1
  P_matrix[, 1] <- 1
  if (l_max >= 1) {
    P_matrix[, 2] <- x
  }

  # Récurrence vectorisée pour l ≥ 2
  if (l_max >= 2) {
    for (l in 2:l_max) {
      n <- l - 1
      P_matrix[, l + 1] <- ((2*n + 1) * x * P_matrix[, l] - n * P_matrix[, l - 1]) / (n + 1)
    }
  }

  # Produit matriciel: Σ coeff[l] · P_l
  sigma <- P_matrix %*% coeff

  return(as.vector(sigma))
}

#' @title Section efficace de réaction (modèle de Breit-Wigner)
#' @description Modélise les pics de résonance nucléaire
#' @param E Énergie(s) en MeV
#' @param E0 Énergie de résonance en MeV
#' @param Gamma Largeur de la résonance en MeV
#' @param sigma0 Amplitude du pic en barn
#' @return Section efficace σ(E) en barn
#' @details Formule de Breit-Wigner:
#'   σ(E) = σ_0 · (Γ²/4) / [(E - E_0)² + (Γ²/4)]
sigma_breit_wigner <- function(E, E0, Gamma, sigma0) {
  sigma0 * (Gamma^2 / 4) / ((E - E0)^2 + (Gamma^2 / 4))
}

#' @title Plusieurs pics de Breit-Wigner
#' @description Superposition de plusieurs résonances
#' @param E Vecteur d'énergies en MeV
#' @param params Data frame avec colonnes: E0, Gamma, sigma0
#' @return Section efficace totale σ_total(E) en barn
#' @examples
#' E <- seq(0.1, 10, length.out = 500)
#' params <- data.frame(
#'   E0 = c(1.5, 3.0, 5.5),
#'   Gamma = c(0.2, 0.3, 0.4),
#'   sigma0 = c(5, 8, 3)
#' )
#' sigma <- sigma_multiresonance(E, params)
sigma_multiresonance <- function(E, params) {
  # Vérification du format
  if (!all(c("E0", "Gamma", "sigma0") %in% names(params))) {
    stop("params doit contenir les colonnes: E0, Gamma, sigma0")
  }

  # Initialisation
  total <- rep(0, length(E))

  # Somme de toutes les résonances
  for (i in 1:nrow(params)) {
    total <- total + sigma_breit_wigner(E,
                                        params$E0[i],
                                        params$Gamma[i],
                                        params$sigma0[i])
  }

  return(total)
}

#' @title Section efficace de capture
#' @description Modèle simple pour la capture neutronique
#' @param E Énergie(s) en eV
#' @param a Coefficient en barn·√eV
#' @param b Coefficient en barn/eV
#' @return Section efficace σ_capture(E) en barn
#' @details σ(E) = a/√E + b·E
#'   Premier terme: capture thermique (loi en 1/v)
#'   Second terme: capture résonnante
sigma_capture <- function(E, a, b) {
  a / sqrt(E) + b * E
}

#' @title Extraction d'une section efficace expérimentale
#' @description Calcule σ à partir de comptages bruts
#' @param counts Nombre de réactions détectées
#' @param N0 Nombre de particules incidentes
#' @param n Densité de cibles (atomes/cm³)
#' @param t Épaisseur de la cible (cm)
#' @param eff Efficacité du détecteur (0 à 1)
#' @return Section efficace en barn
#' @details σ = counts / (N_0 · n · t · ε)
sigma_exp <- function(counts, N0, n, t, eff = 1) {
  if (eff <= 0 || eff > 1) {
    warning("L'efficacité devrait être entre 0 et 1")
  }

  counts / (N0 * n * t * eff)
}

# =======================
# TESTS DE VALIDATION
# =======================

if (FALSE) {  # Mettre TRUE pour exécuter les tests

  cat("=== Tests de validation du module MATH_TOOLS ===\n\n")

  # Test 1: Intégration trapézoïdale
  cat("Test 1: Intégration trapézoïdale\n")
  x <- seq(0, pi, length.out = 100)
  y <- sin(x)
  integrale <- trapz(x, y)
  cat("∫sin(x)dx de 0 à π =", integrale, "(attendu: 2.0)\n")
  cat("Erreur relative:", abs(integrale - 2) / 2 * 100, "%\n\n")

  # Test 2: Polynômes de Legendre
  cat("Test 2: Polynômes de Legendre\n")
  x_test <- 0.5
  cat("P_0(0.5) =", polynome_legendre(0, x_test), "(attendu: 1)\n")
  cat("P_1(0.5) =", polynome_legendre(1, x_test), "(attendu: 0.5)\n")
  cat("P_2(0.5) =", polynome_legendre(2, x_test), "(attendu:", (3*x_test^2 - 1)/2, ")\n\n")

  # Test 3: Diffusion de Rutherford
  cat("Test 3: Diffusion de Rutherford\n")
  sigma_180 <- sigma_rutherford(180, Z1 = 2, Z2 = 79, E = 5)
  cat("σ(180°) pour α sur Au à 5 MeV:", sigma_180, "barn/sr\n\n")

  # Test 4: Breit-Wigner
  cat("Test 4: Résonance de Breit-Wigner\n")
  E_test <- seq(2, 4, length.out = 100)
  sigma_BW <- sigma_breit_wigner(E_test, E0 = 3, Gamma = 0.2, sigma0 = 10)
  cat("Maximum à E = 3 MeV:", max(sigma_BW), "barn (attendu: 10)\n\n")

  # Test 5: Section efficace totale
  cat("Test 5: Section efficace totale (intégration)\n")
  theta <- seq(0, pi, length.out = 200)
  sigma_ang <- sigma_legendre(theta, c(1, 0.3, -0.2))
  sigma_tot <- sigma_total(theta, sigma_ang)
  cat("σ_total =", sigma_tot, "barn\n\n")

  cat("Tous les tests terminés \n")
}
