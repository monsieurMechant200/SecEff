# ============================================================================
# MODULE 2: MARKETING_TOOLS
# Fonctions d'analyse marketing basées sur le concept de section efficace
# ============================================================================

#' @title Section efficace marketing
#' @description Mesure l'efficacite d'une campagne marketing par analogie avec la physique
#' @param conversions Nombre de conversions realisees
#' @param impressions Nombre total d'impressions (expositions)
#' @param densite Score de ciblage ou qualite de l'audience (0-1)
#' @return Efficacite marketing (sans unite)
#' @details
#'   Analogie physique: σ_marketing = N_reactions / (N_projectiles × n_cibles)
#'   Plus σ est eleve, plus la campagne est efficace pour cette audience
#' @examples
#' # Campagne avec 5000 conversions sur 1M d'impressions
#' sigma_marketing(5000, 1e6, densite = 0.7)
#'
#' # Comparer deux segments d'audience
#' sigma_A <- sigma_marketing(3000, 5e5, 0.8)  # Audience ciblée
#' sigma_B <- sigma_marketing(2000, 5e5, 0.4)  # Audience large
sigma_marketing <- function(conversions, impressions, densite) {
  # Validation des entrées
  if (any(conversions < 0) || any(impressions <= 0) || any(densite <= 0)) {
    stop("conversions >= 0, impressions > 0, densite > 0")
  }

  if (any(densite > 1)) {
    warning("La densité devrait typiquement être entre 0 et 1")
  }

  if (any(conversions > impressions)) {
    warning("Conversions > impressions: verifier les donnees")
  }

  conversions / (impressions * densite)
}

#' @title Modele de saturation/fatigue publicitaire
#' @description Modelise la diminution d'efficacite avec l'exposition repetee
#' @param sigma0 Efficacite initiale (premiere exposition)
#' @param mu Coefficient de fatigue publicitaire (> 0)
#' @param x Nombre d'expositions
#' @return Efficacite résiduelle apres x expositions
#' @details
#'   Modèle exponentiel: σ(x) = σ₀ × exp(-μx)
#'   - μ faible: fatigue lente (bon message)
#'   - μ eleve: saturation rapide (message répétitif)
#' @examples
#' # Evolution de l'efficacite sur 20 expositions
#' expositions <- 1:20
#' eff <- sigma_fatigue(sigma0 = 0.05, mu = 0.15, x = expositions)
#' plot(expositions, eff, type = "l")
sigma_fatigue <- function(sigma0, mu, x) {
  # Validation
  if (sigma0 < 0) {
    stop("sigma0 doit être >= 0")
  }

  if (mu < 0) {
    stop("mu doit etre >= 0 (coefficient de fatigue)")
  }

  if (any(x < 0)) {
    stop("x (expositions) doit être >= 0")
  }

  sigma0 * exp(-mu * x)
}

#' @title Taux de conversion apparent
#' @description Calcule le taux de conversion simple (sans pondération)
#' @param conversions Nombre de conversions
#' @param impressions Nombre d'impressions
#' @return Taux de conversion (0-1 ou pourcentage si pct=TRUE)
#' @param pct Si TRUE, retourne en pourcentage
taux_conversion <- function(conversions, impressions, pct = FALSE) {
  if (impressions == 0) {
    stop("Impressions ne peut pas être 0")
  }

  taux <- conversions / impressions

  if (pct) {
    return(taux * 100)
  } else {
    return(taux)
  }
}

#' @title Coût par acquisition (CPA)
#' @description Calcule le cout moyen pour obtenir une conversion
#' @param cout_total Cout total de la campagne (devise)
#' @param conversions Nombre de conversions obtenues
#' @return CPA en unite monetaire
cpa <- function(cout_total, conversions) {
  if (conversions == 0) {
    warning("Aucune conversion: CPA infini")
    return(Inf)
  }

  cout_total / conversions
}

#' @title Retour sur investissement marketing (ROMI)
#' @description Return On Marketing Investment
#' @param revenus Revenus generes par la campagne
#' @param cout_campagne Cout de la campagne
#' @param pct Si TRUE, retourne en pourcentage
#' @return ROMI (ratio ou %)
romi <- function(revenus, cout_campagne, pct = FALSE) {
  if (cout_campagne == 0) {
    stop("Coût de campagne ne peut pas être 0")
  }

  romi_val <- (revenus - cout_campagne) / cout_campagne

  if (pct) {
    return(romi_val * 100)
  } else {
    return(romi_val)
  }
}

#' @title Modele de reponse dose-reponse (Hill)
#' @description Modélise la réponse marketing en fonction du budget
#' @param budget Budget investi
#' @param Emax Réponse maximale atteignable
#' @param EC50 Budget pour atteindre 50% de la réponse max
#' @param n Coefficient de Hill (pente de la courbe)
#' @return Reponse (conversions, revenus, etc.)
#' @details
#'   R(B) = Emax × B^n / (EC50^n + B^n)
#'   Utile pour optimiser l'allocation budgetaire
modele_hill <- function(budget, Emax, EC50, n = 1) {
  if (any(budget < 0) || Emax < 0 || EC50 <= 0 || n <= 0) {
    stop("Tous les parametres doivent etre positifs")
  }

  Emax * (budget^n) / (EC50^n + budget^n)
}

#' @title Allocation budgetaire optimale (2 canaux)
#' @description Trouve la repartition optimale du budget entre deux canaux
#' @param budget_total Budget total disponible
#' @param params_A Vecteur c(Emax_A, EC50_A, n_A) pour canal A
#' @param params_B Vecteur c(Emax_B, EC50_B, n_B) pour canal B
#' @param resolution Nombre de points à tester (défaut: 100)
#' @return Liste avec: budget_A, budget_B, reponse_totale
optimiser_budget <- function(budget_total, params_A, params_B, resolution = 100) {
  # Grille de recherche
  budgets_A <- seq(0, budget_total, length.out = resolution)
  budgets_B <- budget_total - budgets_A

  # Calculer la reponse pour chaque allocation
  reponse_A <- modele_hill(budgets_A, params_A[1], params_A[2], params_A[3])
  reponse_B <- modele_hill(budgets_B, params_B[1], params_B[2], params_B[3])
  reponse_totale <- reponse_A + reponse_B

  # Trouver l'optimum
  idx_opt <- which.max(reponse_totale)

  list(
    budget_A = budgets_A[idx_opt],
    budget_B = budgets_B[idx_opt],
    reponse_A = reponse_A[idx_opt],
    reponse_B = reponse_B[idx_opt],
    reponse_totale = reponse_totale[idx_opt],
    allocation_pct_A = budgets_A[idx_opt] / budget_total * 100
  )
}

#' @title Score de qualite d'audience (Quality Score)
#' @description Evalue la qualité d'un segment d'audience
#' @param taux_clic CTR (Click-Through Rate)
#' @param taux_conversion CVR (Conversion Rate)
#' @param taux_rebond Bounce Rate (0-1)
#' @param poids Vecteurs de ponderation c(w_ctr, w_cvr, w_bounce)
#' @return Score de qualite (0-100)
quality_score <- function(taux_clic, taux_conversion, taux_rebond,
                          poids = c(0.3, 0.5, 0.2)) {
  if (length(poids) != 3 || sum(poids) != 1) {
    stop("poids doit être un vecteur de 3 éléments sommant à 1")
  }

  # Normaliser les metriques (supposer des max raisonnables)
  ctr_norm <- min(taux_clic / 0.1, 1)          # 10% CTR = excellent
  cvr_norm <- min(taux_conversion / 0.05, 1)    # 5% CVR = excellent
  bounce_norm <- 1 - min(taux_rebond / 0.8, 1)  # Inverse (bas = bon)

  # Score pondere
  score <- (poids[1] * ctr_norm +
              poids[2] * cvr_norm +
              poids[3] * bounce_norm) * 100

  return(score)
}

#' @title Modele d'attribution multi-touch
#' @description Attribue le crédit de conversion à differents points de contact
#' @param touchpoints Vecteur du nombre de touchpoints (par canal)
#' @param modele Type d'attribution: "linear", "time_decay", "position"
#' @param poids_position Pour "position": c(premier, milieu, dernier)
#' @return Vecteur des crédits attribués à chaque touchpoint
attribution <- function(touchpoints, modele = "linear",
                        poids_position = c(0.4, 0.2, 0.4)) {
  n <- length(touchpoints)

  if (n == 0) {
    return(numeric(0))
  }

  modele <- match.arg(modele, c("linear", "time_decay", "position"))

  if (modele == "linear") {
    # Attribution égale
    return(rep(1/n, n))

  } else if (modele == "time_decay") {
    # Plus de poids aux touchpoints récents
    poids <- exp(seq(0, 1, length.out = n))
    return(poids / sum(poids))

  } else if (modele == "position") {
    # Poids spécifiques: premier, milieu, dernier
    if (n == 1) {
      return(1)
    } else if (n == 2) {
      return(c(poids_position[1], poids_position[3]))
    } else {
      credits <- numeric(n)
      credits[1] <- poids_position[1]
      credits[n] <- poids_position[3]
      credits[2:(n-1)] <- poids_position[2] / (n - 2)
      return(credits)
    }
  }
}

#' @title Test A/B: Significativite statistique
#' @description Teste si la difference entre deux variantes est significative
#' @param conversions_A Conversions variante A
#' @param impressions_A Impressions variante A
#' @param conversions_B Conversions variante B
#' @param impressions_B Impressions variante B
#' @param alpha Seuil de significativité (défaut: 0.05)
#' @return Liste avec: p_value, significatif, amelioration_relative
test_ab <- function(conversions_A, impressions_A,
                    conversions_B, impressions_B,
                    alpha = 0.05) {
  # Taux de conversion
  p_A <- conversions_A / impressions_A
  p_B <- conversions_B / impressions_B

  # Écart-type poole
  p_pool <- (conversions_A + conversions_B) / (impressions_A + impressions_B)
  se <- sqrt(p_pool * (1 - p_pool) * (1/impressions_A + 1/impressions_B))

  # Statistique Z
  z <- (p_B - p_A) / se

  # P-value (test bilatéral)
  p_value <- 2 * pnorm(-abs(z))

  # Amélioration relative
  amelioration_rel <- (p_B - p_A) / p_A * 100

  list(
    taux_A = p_A,
    taux_B = p_B,
    amelioration_relative_pct = amelioration_rel,
    z_score = z,
    p_value = p_value,
    significatif = p_value < alpha,
    interpretation = if(p_value < alpha) {
      sprintf("Difference significative: B est %.1f%% %s que A",
              abs(amelioration_rel),
              if(amelioration_rel > 0) "meilleur" else "pire")
    } else {
      "Pas de difference significative detectee"
    }
  )
}

#' @title Lifetime Value (LTV) projeté
#' @description Estime la valeur vie client
#' @param revenu_moyen_achat Revenu moyen par achat
#' @param freq_achat_annuelle Frequence d'achat par an
#' @param duree_vie_client Duree de vie client (années)
#' @param taux_actualisation Taux d'actualisation annuel (0-1)
#' @return LTV actualisé
ltv <- function(revenu_moyen_achat, freq_achat_annuelle,
                duree_vie_client, taux_actualisation = 0.1) {

  annees <- 1:duree_vie_client
  revenu_annuel <- revenu_moyen_achat * freq_achat_annuelle

  # Actualisation des flux futurs
  valeurs_actualisees <- revenu_annuel / ((1 + taux_actualisation)^annees)

  sum(valeurs_actualisees)
}

#' @title Tableau de bord marketing complet
#' @description Genere un resume des metriques cles
#' @param conversions Nombre de conversions
#' @param impressions Nombre d'impressions
#' @param clics Nombre de clics
#' @param cout_total Coût total de la campagne
#' @param revenus Revenus généres
#' @return Data frame avec toutes les métriques
dashboard_marketing <- function(conversions, impressions, clics,
                                cout_total, revenus) {

  # Metriques de base
  ctr <- clics / impressions
  cvr <- conversions / clics
  cpa_val <- cpa(cout_total, conversions)
  romi_val <- romi(revenus, cout_total, pct = TRUE)

  # Creer le tableau
  metriques <- data.frame(
    Metrique = c("Impressions", "Clics", "Conversions",
                 "CTR (%)", "CVR (%)", "CPA", "Coût total",
                 "Revenus", "ROMI (%)"),
    Valeur = c(
      impressions,
      clics,
      conversions,
      round(ctr * 100, 2),
      round(cvr * 100, 2),
      round(cpa_val, 2),
      cout_total,
      revenus,
      round(romi_val, 2)
    ),
    stringsAsFactors = FALSE
  )

  return(metriques)
}

# ====================
# TESTS DE VALIDATION
# ====================

if (FALSE) {  # Mettre TRUE pour exécuter les tests

  cat("=== Tests de validation du module MARKETING_TOOLS ===\n\n")

  # Test 1: Section efficace marketing
  cat("Test 1: Section efficace marketing\n")
  sigma1 <- sigma_marketing(5000, 1e6, 0.7)
  sigma2 <- sigma_marketing(3000, 1e6, 0.3)
  cat("Campagne ciblee (d=0.7):", round(sigma1, 6), "\n")
  cat("Campagne large (d=0.3):", round(sigma2, 6), "\n")
  cat("Ratio efficacite:", round(sigma1/sigma2, 2), "x\n\n")

  # Test 2: Fatigue publicitaire
  cat("Test 2: Courbe de fatigue\n")
  expositions <- 1:10
  eff <- sigma_fatigue(sigma0 = 0.05, mu = 0.15, expositions)
  cat("Efficacité apres 1 exposition:", round(eff[1], 4), "\n")
  cat("Efficacité apres 5 expositions:", round(eff[5], 4), "\n")
  cat("Efficacité apres 10 expositions:", round(eff[10], 4), "\n")
  cat("Perte d'efficacite:", round((1 - eff[10]/eff[1])*100, 1), "%\n\n")

  # Test 3: Modele de Hill
  cat("Test 3: Modèle dose-reponse\n")
  budgets <- c(1000, 5000, 10000, 50000)
  reponses <- modele_hill(budgets, Emax = 1000, EC50 = 10000, n = 2)
  cat("Réponses pour differents budgets:\n")
  print(data.frame(Budget = budgets, Conversions = round(reponses, 0)))
  cat("\n")

  # Test 4: Test A/B
  cat("Test 4: Test A/B\n")
  resultat <- test_ab(
    conversions_A = 250, impressions_A = 10000,
    conversions_B = 300, impressions_B = 10000
  )
  cat(resultat$interpretation, "\n")
  cat("P-value:", round(resultat$p_value, 4), "\n\n")

  # Test 5: Optimisation budgetaire
  cat("Test 5: Allocation budgétaire optimale\n")
  opt <- optimiser_budget(
    budget_total = 50000,
    params_A = c(Emax = 500, EC50 = 15000, n = 1.5),
    params_B = c(Emax = 800, EC50 = 20000, n = 2)
  )
  cat("Budget canal A:", round(opt$budget_A, 0),
      sprintf("(%.1f%%)", opt$allocation_pct_A), "\n")
  cat("Budget canal B:", round(opt$budget_B, 0),
      sprintf("(%.1f%%)", 100 - opt$allocation_pct_A), "\n")
  cat("Réponse totale optimale:", round(opt$reponse_totale, 0), "\n\n")

  # Test 6: Dashboard complet
  cat("Test 6: Dashboard marketing\n")
  dashboard <- dashboard_marketing(
    conversions = 500,
    impressions = 100000,
    clics = 5000,
    cout_total = 10000,
    revenus = 25000
  )
  print(dashboard)

  cat("\nTous les tests termines ✓\n")
}
