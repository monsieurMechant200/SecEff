# ============================================================================
# MODULE: MARKETING_ANALYTICS_TOOLS
# Core marketing analysis functions
# ============================================================================

#' @title Conversion Rate
#' @description Calculates the simple conversion rate
#' @param conversions Number of conversions
#' @param impressions Number of impressions
#' @param pct If TRUE, returns as percentage
#' @return Conversion rate (0-1 or percentage)
conversion_rate <- function(conversions, impressions, pct = FALSE) {
  if (impressions == 0) {
    stop("Impressions cannot be 0")
  }

  rate <- conversions / impressions

  if (pct) {
    return(rate * 100)
  } else {
    return(rate)
  }
}

#' @title Cost Per Acquisition (CPA)
#' @description Calculates the average cost to obtain one conversion
#' @param total_cost Total campaign cost (currency)
#' @param conversions Number of conversions obtained
#' @return CPA in monetary units
cpa <- function(total_cost, conversions) {
  if (conversions == 0) {
    warning("No conversions: CPA is infinite")
    return(Inf)
  }

  total_cost / conversions
}

#' @title Return On Marketing Investment (ROMI)
#' @description Calculates marketing ROI
#' @param revenue Revenue generated by the campaign
#' @param campaign_cost Campaign cost
#' @param pct If TRUE, returns as percentage
#' @return ROMI (ratio or %)
romi <- function(revenue, campaign_cost, pct = FALSE) {
  if (campaign_cost == 0) {
    stop("Campaign cost cannot be 0")
  }

  romi_val <- (revenue - campaign_cost) / campaign_cost

  if (pct) {
    return(romi_val * 100)
  } else {
    return(romi_val)
  }
}

#' @title Hill Response Model (Dose-Response)
#' @description Models marketing response as a function of budget
#' @param budget Invested budget
#' @param Emax Maximum achievable response
#' @param EC50 Budget to reach 50% of max response
#' @param n Hill coefficient (curve steepness)
#' @return Response (conversions, revenue, etc.)
#' @details
#'   R(B) = Emax Ã— B^n / (EC50^n + B^n)
#'   Useful for optimizing budget allocation
hill_model <- function(budget, Emax, EC50, n = 1) {
  if (any(budget < 0) || Emax < 0 || EC50 <= 0 || n <= 0) {
    stop("All parameters must be positive")
  }

  Emax * (budget^n) / (EC50^n + budget^n)
}

#' @title Optimal Budget Allocation (2 channels)
#' @description Finds optimal budget split between two channels
#' @param total_budget Total available budget
#' @param params_A Vector c(Emax_A, EC50_A, n_A) for channel A
#' @param params_B Vector c(Emax_B, EC50_B, n_B) for channel B
#' @param resolution Number of test points (default: 100)
#' @return List with: budget_A, budget_B, total_response
optimize_budget <- function(total_budget, params_A, params_B, resolution = 100) {
  # Search grid
  budgets_A <- seq(0, total_budget, length.out = resolution)
  budgets_B <- total_budget - budgets_A

  # Calculate response for each allocation
  response_A <- hill_model(budgets_A, params_A[1], params_A[2], params_A[3])
  response_B <- hill_model(budgets_B, params_B[1], params_B[2], params_B[3])
  total_response <- response_A + response_B

  # Find optimum
  idx_opt <- which.max(total_response)

  list(
    budget_A = budgets_A[idx_opt],
    budget_B = budgets_B[idx_opt],
    response_A = response_A[idx_opt],
    response_B = response_B[idx_opt],
    total_response = total_response[idx_opt],
    allocation_pct_A = budgets_A[idx_opt] / total_budget * 100
  )
}

#' @title Audience Quality Score
#' @description Evaluates the quality of an audience segment
#' @param click_rate CTR (Click-Through Rate)
#' @param conversion_rate CVR (Conversion Rate)
#' @param bounce_rate Bounce Rate (0-1)
#' @param weights Weighting vector c(w_ctr, w_cvr, w_bounce)
#' @return Quality score (0-100)
quality_score <- function(click_rate, conversion_rate, bounce_rate,
                          weights = c(0.3, 0.5, 0.2)) {
  if (length(weights) != 3 || sum(weights) != 1) {
    stop("weights must be a 3-element vector summing to 1")
  }

  # Normalize metrics (assuming reasonable maximums)
  ctr_norm <- min(click_rate / 0.1, 1)          # 10% CTR = excellent
  cvr_norm <- min(conversion_rate / 0.05, 1)    # 5% CVR = excellent
  bounce_norm <- 1 - min(bounce_rate / 0.8, 1)  # Inverse (low = good)

  # Weighted score
  score <- (weights[1] * ctr_norm +
              weights[2] * cvr_norm +
              weights[3] * bounce_norm) * 100

  return(score)
}

#' @title Multi-Touch Attribution Model
#' @description Attributes conversion credit to different touchpoints
#' @param touchpoints Vector of touchpoint numbers (per channel)
#' @param model Attribution type: "linear", "time_decay", "position"
#' @param position_weights For "position": c(first, middle, last)
#' @return Vector of credits attributed to each touchpoint
attribution <- function(touchpoints, model = "linear",
                        position_weights = c(0.4, 0.2, 0.4)) {
  n <- length(touchpoints)

  if (n == 0) {
    return(numeric(0))
  }

  model <- match.arg(model, c("linear", "time_decay", "position"))

  if (model == "linear") {
    # Equal attribution
    return(rep(1/n, n))

  } else if (model == "time_decay") {
    # More weight to recent touchpoints
    weights <- exp(seq(0, 1, length.out = n))
    return(weights / sum(weights))

  } else if (model == "position") {
    # Specific weights: first, middle, last
    if (n == 1) {
      return(1)
    } else if (n == 2) {
      return(c(position_weights[1], position_weights[3]))
    } else {
      credits <- numeric(n)
      credits[1] <- position_weights[1]
      credits[n] <- position_weights[3]
      credits[2:(n-1)] <- position_weights[2] / (n - 2)
      return(credits)
    }
  }
}

#' @title A/B Test: Statistical Significance
#' @description Tests if the difference between two variants is significant
#' @param conversions_A Conversions variant A
#' @param impressions_A Impressions variant A
#' @param conversions_B Conversions variant B
#' @param impressions_B Impressions variant B
#' @param alpha Significance threshold (default: 0.05)
#' @return List with: p_value, significant, relative_improvement
ab_test <- function(conversions_A, impressions_A,
                    conversions_B, impressions_B,
                    alpha = 0.05) {
  # Conversion rates
  p_A <- conversions_A / impressions_A
  p_B <- conversions_B / impressions_B

  # Pooled standard deviation
  p_pool <- (conversions_A + conversions_B) / (impressions_A + impressions_B)
  se <- sqrt(p_pool * (1 - p_pool) * (1/impressions_A + 1/impressions_B))

  # Z-statistic
  z <- (p_B - p_A) / se

  # P-value (two-tailed test)
  p_value <- 2 * pnorm(-abs(z))

  # Relative improvement
  relative_improvement <- (p_B - p_A) / p_A * 100

  list(
    rate_A = p_A,
    rate_B = p_B,
    relative_improvement_pct = relative_improvement,
    z_score = z,
    p_value = p_value,
    significant = p_value < alpha,
    interpretation = if(p_value < alpha) {
      sprintf("Significant difference: B is %.1f%% %s than A",
              abs(relative_improvement),
              if(relative_improvement > 0) "better" else "worse")
    } else {
      "No significant difference detected"
    }
  )
}

#' @title Customer Lifetime Value (LTV)
#' @description Estimates customer lifetime value
#' @param avg_purchase_revenue Average revenue per purchase
#' @param annual_purchase_freq Purchase frequency per year
#' @param customer_lifespan Customer lifespan (years)
#' @param discount_rate Annual discount rate (0-1)
#' @return Discounted LTV
ltv <- function(avg_purchase_revenue, annual_purchase_freq,
                customer_lifespan, discount_rate = 0.1) {

  years <- 1:customer_lifespan
  annual_revenue <- avg_purchase_revenue * annual_purchase_freq

  # Discount future cash flows
  discounted_values <- annual_revenue / ((1 + discount_rate)^years)

  sum(discounted_values)
}

#' @title Complete Marketing Dashboard
#' @description Generates a summary of key metrics
#' @param conversions Number of conversions
#' @param impressions Number of impressions
#' @param clicks Number of clicks
#' @param total_cost Total campaign cost
#' @param revenue Revenue generated
#' @return Data frame with all metrics
marketing_dashboard <- function(conversions, impressions, clicks,
                                total_cost, revenue) {

  # Basic metrics
  ctr <- clicks / impressions
  cvr <- conversions / clicks
  cpa_val <- cpa(total_cost, conversions)
  romi_val <- romi(revenue, total_cost, pct = TRUE)

  # Create table
  metrics <- data.frame(
    Metric = c("Impressions", "Clicks", "Conversions",
               "CTR (%)", "CVR (%)", "CPA", "Total Cost",
               "Revenue", "ROMI (%)"),
    Value = c(
      impressions,
      clicks,
      conversions,
      round(ctr * 100, 2),
      round(cvr * 100, 2),
      round(cpa_val, 2),
      total_cost,
      revenue,
      round(romi_val, 2)
    ),
    stringsAsFactors = FALSE
  )

  return(metrics)
}


